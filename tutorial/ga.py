import subprocess, os, time, random,resource, copy, numpy, array, json, networkx, pickle
from scoop import futures


import matplotlib.pyplot as plt
import matplotlib.colors as colors
from matplotlib import animation

import pandas as pd

from deap import algorithms
from deap import base
from deap import benchmarks
from deap.benchmarks.tools import diversity, convergence, hypervolume
from deap import creator
from deap import tools

import seaborn
seaborn.set(style="whitegrid")

import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
handler = logging.FileHandler('optimization_scoop.log')
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)

creator.create("FitnessMin", base.Fitness, weights=(-1.0, -1.0))
creator.create("Individual", array.array, typecode='d', fitness=creator.FitnessMin)

toolbox = base.Toolbox()

# Problem definition: minimized time and memory
# Memory [1, 1000Mb]
# Time [1, 1000s]

BOUND_LOW, BOUND_UP = 0.0, 1.0

# 4 variables (size of vector, thread, number of buffered events, number of all events):
# Vector [1,512]
# Thread [1,32]
# Buffered [1,100]
# Total [1, 100] {buffered < total}
# Priority [0,1]
# Steps [1,1000000]

NDIM = 2

def randinit(low, up, size=None):
   try:
       return [random.randint(a, b) for a, b in zip(low, up)]
   except TypeError:
       return [random.randint(a, b) for a, b in zip([low] * size, [up] * size)]

def uniform(low, up, size=None):
   try:
       return [random.uniform(a, b) for a, b in zip(low, up)]
   except TypeError:
       return [random.uniform(a, b) for a, b in zip([low] * size, [up] * size)]

def getMem():
   info = ROOT.ProcInfo_t()
   ROOT.gSystem.GetProcInfo(info);
   mem = float(info.fMemResident)
   return mem*1e-3

def evaluation_geantv(individual):
   # Stupid solution
   global threads, vector
   print "Stupid individual generated by Deap: ", individual

   # Changing generation of random data
   # Threads initialization
   if (int(individual[0]) > 16):
       individual[0] = random.randint(1,16)
       threads = int(individual[0])
   elif (int(individual[0]) == 0):
       threads = 1
   # Total number of events number
   if (int(individual[2]) > 50):
       individual[2] = random.randint(1,50)
       allev = int(individual[2])
   elif (int(individual[2]) == 0):
       allev = 1
   else:
       allev = int(individual[2])
   # Buffered events
   if (int(individual[3]) > allev):
       individual[3] = random.randint(1,allev)
       buffev = int(individual[3])
   elif (int(individual[3]) == 0):
       buffev = 2
   else:
       buffev = int(individual[3])
   # Vector size
   # Changing generation of random data
   if (int(individual[1]) < 1):
       vector = int(individual[1])
   else:
       vectors = [8, 16, 32, 64, 128, 256, 512]
       individual[1] = vectors[random.randint(0,6)]
       vector = int(individual[1])
   # Priority
   individual[4] = random.uniform(0,0.1)
   priority = float(individual[4])
   # Steps
   individual[3] = random.randint(1,1000)
   steps = int(individual[3])

   print 'Number of threads: ', threads
   print 'Number of all events: ', allev
   print 'Number of buffered events: ', buffev
   print 'Number of learning steps: ', steps
   print 'Vector of particles: ', vector
   print 'Priority settings:', priority
   print("XXXXXXXXXXXXXXXXXXXXXXX")
   print "Game starts.."

   p = os.popen("sh run-pca.sh %s %s %s %s %s %s" % (threads, allev, buffev, vector, priority, steps))
   output = p.readline()
   p.close()
   print "Result of evaluation:", output
   output_result = output.split(',')
   # Sometimes  I have problems with evaluation (need to be checked - segfault)
   if not bool(output_result[0].strip()):
       print "List is empty (GRRR) -> let's recalculate value again"
       output_result = evaluation_geantv(individual)
       return float(output_result[0]),int(output_result[1])
   else:
       print("XXXXXXXXXXXXXXXXXXXXXXX")
       return float(output_result[0]),int(output_result[1])


def animate(frame_index, logbook):
    fig, ax = plt.subplots(1, figsize=(4,4))
    #'Updates all plots to match frame _i_ of the animation.'
    ax.clear()
    fronts = tools.emo.sortLogNondominated(logbook.select('pop')[frame_index],
                                           len(logbook.select('pop')[frame_index]))
    for i,inds in enumerate(fronts):
        par = [toolbox.evaluate(ind) for ind in inds]
        df = pd.DataFrame(par)
        df.plot(ax=ax, kind='scatter', label='Front ' + str(i+1),
                 x=df.columns[0], y =df.columns[1], alpha=0.47,
                 color=plot_colors[i % len(plot_colors)])

    ax.set_title('$t=$' + str(frame_index))
    ax.set_xlabel('RT');ax.set_ylabel('Memory')
    return None

def variate(ind1, ind2, mate, mutate):
    c1, c2 = mate(ind1, ind2)
    c1 = mutate(c1)
    c2 = mutate(c2)
    return c1, c2

toolbox.register("attr_float", uniform, BOUND_LOW, BOUND_UP, NDIM)
toolbox.register("individual", tools.initIterate, creator.Individual, toolbox.attr_float)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("evaluate", lambda ind: benchmarks.dtlz2(ind, 2))
toolbox.register("mate", tools.cxSimulatedBinary, eta=20.0)
toolbox.register("mutate", tools.mutPolynomialBounded, low=0, up=10000, eta=20.0, indpb=1.0/NDIM)
toolbox.register("select", tools.selNSGA2)
toolbox.register("map", futures.map)

def main(seed=None):
   random.seed(seed)

   NGEN = 2
   MU = 4
   CXPB = 0.6
   pop = toolbox.population(n=MU)

   stats = tools.Statistics(lambda ind: ind.fitness.values)
   stats.register("min", numpy.min, axis=0)
   stats.register("max", numpy.max, axis=0)
   stats.register("pop", copy.deepcopy)

   history = tools.History()
   # Decorate the variation operators
   #toolbox.register("variate", variate, mate=toolbox.mate, mutate=toolbox.mutate)
   #toolbox.decorate("variate", history.decorator)
   toolbox.decorate("mate", history.decorator)
   toolbox.decorate("mutate", history.decorator)

   fitnesses = toolbox.map(toolbox.evaluate, pop)
   for ind, fit in zip(pop, fitnesses):
       ind.fitness.values = fit

   plt.figure(figsize=(10,4))
   plt.subplot(1,2,1)
   for ind in pop: plt.plot(ind[0], ind[1], 'k.', ms=3)
   plt.xlabel('$x_1$');plt.ylabel('$x_2$');plt.title('Decision space');
   plt.subplot(1,2,2)
   for ind in pop: plt.plot(ind.fitness.values[0], ind.fitness.values[1], 'k.', ms=3)
   plt.xlabel('$f_1(\mathbf{x})$');plt.ylabel('$f_2(\mathbf{x})$');
   plt.xlim((0.5,3.6));plt.ylim((0.5,3.6)); plt.title('Objective space');
   plt.savefig("objective.png", dpi=200)

   logbook = tools.Logbook()
   logbook.header = "gen", "evals", "fitness", "size", "pop","ind"
   pickle.dump(logbook, open('nsga_ii-results.pickle', 'wb'),
           pickle.HIGHEST_PROTOCOL)

   hof = tools.ParetoFront()

   # Evaluate the individuals with an invalid fitness
   invalid_ind = [ind for ind in pop if not ind.fitness.valid]
   fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
   for ind, fit in zip(invalid_ind, fitnesses):
       ind.fitness.values = fit


   # This is just to assign the crowding distance to the individualis
   # no actual selection is done
   pop = toolbox.select(pop, len(pop))

   record = stats.compile(pop)
   logbook.record(gen=0, evals=len(invalid_ind), **record)
   print(logbook.stream)

   # Begin the generational process
   for gen in range(1, NGEN):
       # Vary the population
       offspring = tools.selTournamentDCD(pop, len(pop))
       offspring = [toolbox.clone(ind) for ind in offspring]

       for ind1, ind2 in zip(offspring[::2], offspring[1::2]):
           if random.random() <= CXPB:
               toolbox.mate(ind1, ind2)

           toolbox.mutate(ind1)
           toolbox.mutate(ind2)
           del ind1.fitness.values, ind2.fitness.values

       # Evaluate the individuals with an invalid fitness
       invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
       fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
       for ind, fit in zip(invalid_ind, fitnesses):
           ind.fitness.values = fit

       print "Evaluated %i individuals" % len(invalid_ind)

       pop = toolbox.select(pop+offspring, len(offspring))
       hof.update(pop)

       # Select the next generation population
       pop = toolbox.select(pop + offspring, MU)
       record = stats.compile(pop)
       logbook.record(gen=gen, evals=len(invalid_ind), **record)
       print(logbook.stream)

       plt.close("all")
       front = numpy.array([ind.fitness.values for ind in pop])
       plt.figure(figsize=(10,10))
       #fig,ax = plt.subplots(1,gen)
       plt.scatter(front[:,0], front[:,1], c="b")
       #locals()["ax"+str(gen)]=plt.scatter(front[:,0], front[:,1], c="b")
       #plt.tight_layout()
       plt.xlabel("RT(Time)")
       plt.ylabel("Memory usage, Mb")
       plt.savefig("front_scoop_gen"+str(gen)+".png", dpi=200)

   fits = [ind.fitness.values[0] for ind in pop]
   print("Pareto individuals are:")
   for ind in hof:
       print ind, ind.fitness.values

   print("Final population hypervolume is %f" % hypervolume(pop, [11.0, 11.0]))

   print("XXXXXXXXXXX Making more plots XXXXXXXXXXXX")
   fronts_s = tools.emo.sortLogNondominated(pop, len(pop))
   plot_colors = ('b','r', 'g', 'm', 'y', 'k', 'c')
   fig, ax = plt.subplots(1, figsize=(10,10))
   for i,inds in enumerate(fronts_s):
       par = [toolbox.evaluate(ind) for ind in inds]
       df = pd.DataFrame(par)
       df.plot(ax=ax, kind='scatter', label='Front ' + str(i+1),
                 x=df.columns[0], y=df.columns[1],
                 color=plot_colors[i % len(plot_colors)])
   plt.xlabel('$f_1(\mathbf{x})$');plt.ylabel('$f_2(\mathbf{x})$');
   plt.savefig("front_scoop.png", dpi=200)

if __name__ == "__main__":
   main()
